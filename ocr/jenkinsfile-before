pipeline {
  agent any

  environment {
    DRIVE_FOLDER = '1-IdLc7JASMb5dAY00mgAhUYoo-ZJQars'
    IMAGE_NAME = 'ocr-ci:latest'
  }

  stages {

    stage('0. Clean & Checkout') {
      steps {
        echo 'ðŸ§¹ Cleaning workspace before checkout'
        deleteDir()
        echo 'ðŸ“¥ Checking out source code'
        checkout scm
      }
    }

    stage('1. Build CI Docker Image') {
      steps {
        dir('ocr') {
          sh """
            docker build -t ${IMAGE_NAME} \\
              -f Docker/Dockerfile.ci \\
              .
          """
        }
      }
    }

    stage('2. Create Timestamped File') {
      steps {
        script {
          // Create the random file in the real workspace
          def raw = sh(
            script: """
              docker run --rm \\
                -v "${WORKSPACE}:/data" \\
                -w /data \\
                ${IMAGE_NAME} \\
                python3 /workspace/upload_to_drive.py --create
            """,
            returnStdout: true
          ).trim()

          echo "ðŸ“„ Create Output:\n${raw}"

          def parts = raw.split('File created:')
          if (parts.size() < 2) {
            error "âŒ Failed to create timestamped file"
          }
          env.FILE_NAME = parts[1].trim()
          echo "ðŸ“„ Created file: ${env.FILE_NAME}"
        }
      }
    }

    stage('3. Upload File to Drive') {
      steps {
        withCredentials([file(credentialsId: 'gcs-sa-key', variable: 'GDRIVE_SA_FILE')]) {
          script {
            def raw = sh(
              script: """
                docker run --rm \\
                  -e DRIVE_FOLDER="${DRIVE_FOLDER}" \\
                  -v "${GDRIVE_SA_FILE}:/tmp/sa.json:ro" \\
                  -v "${WORKSPACE}/${FILE_NAME}:/data/${FILE_NAME}:ro" \\
                  ${IMAGE_NAME} \\
                  python3 /workspace/upload_to_drive.py \\
                    --upload --key /tmp/sa.json \\
                    --folder "$DRIVE_FOLDER" \\
                    --file "/data/${FILE_NAME}"
              """,
              returnStdout: true
            ).trim()

            echo "ðŸš€ Upload Output:\n${raw}"

            def parts2 = raw.split('with ID:')
            if (parts2.size() < 2) {
              error "âŒ Failed to extract file ID"
            }
            env.FILE_ID = parts2[1].trim().split()[0]
            echo "ðŸ†” Extracted file ID: ${env.FILE_ID}"
          }
        }
      }
    }

    stage('4. Verify Upload') {
      steps {
        withCredentials([file(credentialsId: 'gcs-sa-key', variable: 'GDRIVE_SA_FILE')]) {
          script {
            def out = sh(
              script: """
                docker run --rm \\
                  -v "${GDRIVE_SA_FILE}:/tmp/sa.json:ro" \\
                  -v "${WORKSPACE}/${FILE_NAME}:/data/${FILE_NAME}:ro" \\
                  ${IMAGE_NAME} \\
                  python3 /workspace/upload_to_drive.py \\
                    --verify \\
                    --key /tmp/sa.json \\
                    --id "${FILE_ID}" \\
                    --file "/data/${FILE_NAME}"
              """,
              returnStdout: true
            ).trim()

            echo "ðŸ” Verification output:\n${out}"

            // 1) Check ID match
            def actualIdLine = out.split('\n').find { it.startsWith('id:') } ?: ''
            def actualId = actualIdLine.tokenize(':').last()
            if (actualId != env.FILE_ID) {
              error """âŒ Verification failed: ID mismatch
                      â€¢ Expected: ${env.FILE_ID}
                      â€¢ Got     : ${actualId}
                    Full verify log above."""
            }

            // 2) Check content match marker
            if (!out.contains('Content matches local file')) {
              error """âŒ Verification failed: content mismatch
                      Inspect â€œ=== Remote Content ===â€ vs â€œ=== Local Content ===â€ in the log above."""
            }

            echo "âœ… Verified ID and content match successfully."
          }
        }
      }
    }
  }

  post {
    always {
      echo 'ðŸ§¹ Final cleanup'
      cleanWs()
    }
  }
}


#!/usr/bin/env python3
import os
import sys
import argparse
import logging
import random
import string
from datetime import datetime
from google.oauth2 import service_account
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload, MediaIoBaseDownload
from googleapiclient.errors import HttpError
from io import BytesIO

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')


def get_drive_service(key_file: str, scopes: list):
    try:
        creds = service_account.Credentials.from_service_account_file(key_file, scopes=scopes)
        return build('drive', 'v3', credentials=creds)
    except Exception as e:
        logging.error(f"Failed to create Google Drive service: {e}")
        sys.exit(1)

def upload_to_drive(key_file: str, folder_id: str, file_path: str):
    if not os.path.exists(file_path):
        logging.error(f"File not found: {file_path}")
        sys.exit(1)

    service = get_drive_service(key_file, ['https://www.googleapis.com/auth/drive'])
    file_name = os.path.basename(file_path)
    metadata = {'name': file_name}
    if folder_id:
        metadata['parents'] = [folder_id]

    media = MediaFileUpload(file_path, resumable=True)

    try:
        logging.info(f"Uploading '{file_name}' to Google Drive...")
        file = service.files().create(
            body=metadata,
            media_body=media,
            fields='id,name,webViewLink'
        ).execute()

        print(f'Uploaded {file_name} with ID: {file["id"]}')
        print(f'Verified upload: name="{file["name"]}", link={file["webViewLink"]}')
    except HttpError as e:
        logging.error(f"Upload failed: {e}")
        sys.exit(1)


def verify_file(key_file: str, file_id: str, local_path: str):
    service = get_drive_service(key_file, ['https://www.googleapis.com/auth/drive'])
    try:
        # 1) Fetch metadata
        f = service.files().get(fileId=file_id, fields='id,name,webViewLink').execute()
        print(f'id:{f["id"]}')
        print(f'name:{f["name"]}')
        print(f'link:{f["webViewLink"]}')

        # 2) Download remote content
        request = service.files().get_media(fileId=file_id)
        fh = BytesIO()
        downloader = MediaIoBaseDownload(fh, request)
        done = False
        while not done:
            _, done = downloader.next_chunk()
        remote_content = fh.getvalue().decode('utf-8')

        # 3) Read local content
        with open(local_path, 'r') as lf:
            local_content = lf.read()

        # 4) Compare
        if remote_content == local_content:
            print('Content matches local file')
        else:
            print('Content mismatch!')
            print('=== Remote Content ===')
            print(remote_content)
            print('=== Local Content ===')
            print(local_content)
            sys.exit(1)

    except HttpError as e:
        logging.error(f"Verification failed: {e}")
        sys.exit(1)

def create_random_file() -> str:
    timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H%M%SZ')
    file_name = f"{timestamp}.txt"
    content = ''.join(random.choices(string.ascii_letters + string.digits, k=100))
    with open(file_name, 'w') as f:
        f.write(content)
    logging.info(f"Created random file: {file_name}")
    return file_name

def main():
    parser = argparse.ArgumentParser(description="Upload, verify, or create a random file")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--upload', action='store_true', help='Upload a file to Drive')
    group.add_argument('--verify', action='store_true', help='Verify a file by ID')
    group.add_argument('--create', action='store_true', help='Create a random .txt file with UTC timestamp')

    parser.add_argument('--key', help='Path to service account JSON key')
    parser.add_argument('--folder', default='', help='Drive folder ID for uploads')
    parser.add_argument('--file', help='Local file path (for upload or verify)')
    parser.add_argument('--id', dest='file_id', help='Drive file ID for verification')

    args = parser.parse_args()

    if args.create:
        name = create_random_file()
        print(f"âœ… File created: {name}")

    elif args.upload:
        if not args.key or not args.file:
            parser.error('--upload requires --key <KEY_FILE> and --file <PATH>')
        upload_to_drive(args.key, args.folder, args.file)

    elif args.verify:
        if not args.key or not args.file_id or not args.file:
            parser.error('--verify requires --key <KEY_FILE>, --id <FILE_ID>, and --file <LOCAL_PATH>')
        verify_file(args.key, args.file_id, args.file)

if __name__ == '__main__':
    main()
